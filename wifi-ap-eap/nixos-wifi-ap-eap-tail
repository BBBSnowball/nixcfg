# This file will be combined with some config variables
# to produce the nixos-wifi-ap-eap script.
#
# The following config values are required:
# - SERVERNAME
# - SECRETS_DIR
# - CERTS_DIR
# - SSID
# - CLIENT_CERT_VALID_DAYS
# - PATH with coreutils, sed, grep, pwgen, openssl, perl, zip, unzip, eapol_test

set -e

cmd_client_add() {
  cn="$1"
  email="${2:-$cn@$SERVERNAME}"
  days="${3:-$CLIENT_CERT_VALID_DAYS}"
  pwfile="$4"
  if [ -z "$cn" ] ; then
    echo "Usage: $0 client add username [email] [days] [passwordFile]" >&2
    echo ""
    echo "Default email is \"username@$SERVERNAME\"."
    echo "Default valid days is set in NixOS config. It is $CLIENT_CERT_VALID_DAYS."
    echo "If passwordFile is omitted, an interactive password"
    echo "prompt will be used. Set it to \"-gen\" to generate"
    echo "a new random password (will be displayed on stdout)."
    exit 1
  fi

  if [ -n "$pwfile" -a "$pwfile" != "-gen" ] ; then
    pwfile="$(realpath "$pwfile")"
  fi
  output="$(realpath "$cn".zip)"

  #NOTE The FreeRadius makefile uses part of email as user name
  #     but we are enforcing identity==cn for the client so we
  #     use cn for the file names.
  username="$cn"

  cd $CERTS_DIR
  umask 077
  if [ -e "user-cert-$username" ] ; then
    echo "Directory already exists. If this is left over from a previous failed attempt, you can delete it:" >&2
    echo "  $(realpath "user-cert-$username")" >&2
    exit 1
  fi
  mkdir "user-cert-$username"
  cd "user-cert-$username"
  cp ../client.cnf .
  sed -i 's_^\(dir\s*=\s*\).*_\1../_ ; /^\(emailAddress\|commonName\) *=/ d' client.cnf
  echo "emailAddress = $email" >>client.cnf
  echo "commonName = $cn"      >>client.cnf
  # We always update default_days because the file contains the default setting
  # from the time it was created. The user may have changed the default.
  sed -i "s/^\\(default_days\s*=\s*\\).*/\\1$days/" client.cnf

  if [ -z "$pwfile" ] ; then
    read -s -p "Password for new key: " pw1
    echo
    read -s -p "Again: " pw2
    echo
    if [ "$pw1" != "$pw2" ] ; then
      echo "Passwords do not match!" >&2
      cd ..
      rm -rf "user-cert-$username"
      exit 1
    elif [ "${#pw1}" -lt 4 ] ; then
      echo "Password too short. OpenSSL will only accept passwords with at least 4 characters." >&2
      cd ..
      rm -rf "user-cert-$username"
      exit 1
    fi
    echo "$pw1" >pw1
  elif [ "$pwfile" == "-gen" ] ; then
    pwgen -AB0 8 1 >pw1
    echo "Password for new certificate: $(cat pw1)"
  else
    ln -s "$pwfile" pw1
  fi

  # Duplicate the password because OpenSSL will use the first line for passin and the second for passout.
  (cat pw1; cat pw1) >>pw

  sed -n '/output_password/ s/.*= //p' ../ca.cnf >pw_ca

  set -x
  # generate key and csr
  openssl req -new -out client.csr -keyout client.key -config ./client.cnf -passout file:pw
  # sign csr to generate certificate
  openssl ca -batch -keyfile ../ca.key -cert ../ca.pem -in client.csr  -passin file:pw_ca -out client.crt -extensions xpclient_ext -extfile ../xpextensions -config ./client.cnf
  # combine key and cert to generate binary pkcs12 file
  openssl pkcs12 -export -in client.crt -inkey client.key -out "$username.p12"  -passin file:pw -passout file:pw
  # generate ascii cert
  openssl pkcs12 -in "$username.p12" -out "$username.pem" -passin file:pw -passout file:pw
  # verify
  #c_rehash .
  openssl verify -CApath ../ca_dir "$username.pem"
  set +x

  cp ../ca.pem "$SERVERNAME.pem"  # Linux
  cp ../ca.pem "$SERVERNAME.crt"  # Android needs different extension
  cp ../ca.der "$SERVERNAME.der"  # Windows

  cat >README.txt <<EOF
Use these settings:
  SSID: $SSID
  Security: WPA2 Enterprise (EAP)
  Autentication / EAP method: TLS (not TTLS!)
  CA certificate: $SERVERNAME.pem or $SERVERNAME.der or $SERVERNAME.crt
  Domain: $SERVERNAME
  Identity: $cn
  User certificate and private key: $username.pem or $username.p12

You may have to import the certificates if the settings dialog doesn't
let you choose a file. You can usually do that by opening the certificate
file (e.g. double-click the file). On Android, make sure that you select
"wifi" instead of "VPN" when importing the file.

If the dialog only asks for username and password instead of a user certificate,
you have selected the wrong EAP method (see above). It will not work without
the user certificate. You still need the password for the certificate file.
You should have received this password in addition to these files.
EOF

  zip $output README.txt "$SERVERNAME.pem" "$SERVERNAME.der" "$SERVERNAME.crt" "$username.p12" "$username.pem"

  cd ..
  rm -rf "user-cert-$username"

  echo "Certificate has been stored in $output"
}

cmd_client_test() {
  zip="$1"
  if [ -z "$zip" ] ; then
    echo "Usage: $0 client test usercert.zip" >&2
    echo ""
    echo "The input file must be a ZIP file that has been generated by"
    echo "`$0 client add ...`."
    exit 1
  fi
  zip="$(realpath "$zip")"

  umask 077
  tmp="$(mktemp -d wifi_eap_client_testXXXXXXXX)"
  cd "$tmp"
  unzip "$zip"

  identity="$(sed -n 's/^ *Identity: \(.*\)$/\1/p' README.txt)"
  domain="$(sed -n 's/^ *Domain: \(.*\)$/\1/p' README.txt)"
  if [ -z "$identity" -o -z "$domain" ] ; then
    echo "ERROR: Couldn't extract identity and/ or domain from README.txt" >&2
    echo "  Identity: $identity"
    echo "  Domain:   $domain"
    exit 1
  fi

  if [ ! -f "$identity.pem" ] ; then
    echo "ERROR: User certificate not found: $identity.pem" >&2
    exit 1
  fi
  if [ ! -f "$domain.pem" ] ; then
    echo "ERROR: Server certificate not found: $domain.pem" >&2
    exit 1
  fi

  RADIUS_SECRET="$(sed -n 's/secret *= *//p' "$SECRETS_DIR/client-secret.conf")"
  if [ -z "$RADIUS_SECRET" ] ; then
    echo "ERROR: Couldn't get radius secret from $SECRETS_DIR/client-secret.conf" >&2
    exit 1
  fi

  read -s -p "Password for user key: " pw

  echo "$pw" >pw
  if ! openssl rsa -in "$identity.pem" -passin file:pw </dev/null | grep -q "BEGIN RSA PRIVATE KEY" ; then
    echo "ERROR: Couldn't decrypt $identity.pem. Wrong password?" >&2
    exit 1
  fi

  cat >config <<EOF
    network={
      eap=TLS
      key_mgmt=IEEE8021X
      identity="$identity"
      client_cert="$identity.pem"
      private_key="$identity.pem"
      private_key_passwd="$pw"
      ca_cert="$domain.pem"
    }
EOF

  EAPOL_TEST_SECRET="$RADIUS_SECRET" eapol_test -c config

  cd ..
  rm -r "$tmp"
}

cmd_client_list() {
  case "$1" in
    --raw)
      cd $CERTS_DIR
      openssl ca -updatedb -config ca.cnf -passin pass:whatever
      cat index.txt
      echo
      echo "V - valid, R - revoked, E - expired"
      echo "see https://pki-tutorial.readthedocs.io/en/latest/cadb.html"
      ;;
    "")
      cd $CERTS_DIR
      openssl ca -updatedb -config ca.cnf -passin pass:whatever >/dev/null
      printf "No.  Type    %-30s  %-50s  Status\n" "Username" "Email"
      printf -- "---  ----    %-30s  %-50s  ------\n" "--------" "-----"
      while read line ; do
        status="$(echo "$line"|cut -f 1)"
        valid_until="$(echo "$line"|cut -f 2)"
        revocation_time="$(echo "$line"|cut -f 3)"
        serial="$(echo "$line"|cut -f 4)"
        filename="$(echo "$line"|cut -f 5)"
        dn="$(echo "$line"|cut -f 6)"
        #echo "$status,$valid_until,$revocation_time,$serial,$filename,$dn"
        x="${dn#*/CN=}"
        cn="${x%/emailAddress=*}"
        email="${dn#*/emailAddress=}"
        type="$(sed -n 's/^\s*TLS Web \(Server\|Client\) Authentication$/\1/p' "$serial.pem" 2>/dev/null)"
        type="${type,,}"
        printf "%2s:  %-6s  %-30s  %-50s  " "$serial" "${type:-???}" "$cn" "$email"
        case "$status" in
          V) printf "valid until %s\n" "$valid_until";;
          R) printf "revoked at  %s\n" "$revocation_time";;
          E) printf "expired at  %s\n" "$valid_until";;
          *) printf "unknown\n";;
        esac
      done <index.txt
      ;;
    *)
      echo "Usage: $0 client list [--raw]" >&2
      exit 1
      ;;
  esac
}

cmd_client_revoke() {
  if [ -z "$1" ] ; then
    echo "Usage: $0 client revoke regex [-y]" >&2
    echo "  Use \"-y\" to auto-accept confirmation."
    exit 1
  fi

  cd $CERTS_DIR
  lines="$(egrep "$1" index.txt || true)"

  if [ -z "$lines" ] ; then
    echo "no match" >&2
    exit 1
  elif [ "$(echo "$lines" | wc -l)" != 1 ] ; then
    echo "more than one match" >&2
    echo "$lines" | head -n10
    exit 1
  fi

  serial="$(echo "$lines" | cut -f 4)"

  if [ ! -f "$serial.pem" ] || ! grep -q "TLS Web Client Authentication" "$serial.pem" 2>/dev/null ; then
    echo "certificate file doesn't exist or is not a client certificate ($serial.pem)" >&2
    exit 1
  fi

  if [ "$2" == "-y" ] ; then
    echo "Revoking $serial.pem: $lines"
  else
    echo "Revoke $serial.pem?"
    echo "  $lines"
    read -p "Revoke? [y/n] " confirm
    if [ "$confirm" != "y" ] ; then
      echo "Aborting."
      exit 1
    fi
  fi

  openssl ca -config ca.cnf -passin pass:whatever -revoke "$serial.pem"
  cmd_client_updatecrl
}

cmd_client_updatecrl() {
  cd $CERTS_DIR
  openssl ca -config ca.cnf -passin pass:whatever -gencrl >ca.crl
  hash="$(openssl x509 -subject_hash -noout -in ca.pem)"
  cp ca.crl ca_dir/
  oldfile="$(ls -1t ca_dir/"$hash".r* | head -n1)"
  num="${oldfile#*.r}"
  if [ -n "$num" -a "1${num}" -ge 10 ] ; then
    ln -sf ca.crl "ca_dir/$hash.r$[$num+1]"
    find ca_dir -name "$hash.r*" -mtime +1 -exec rm -f {} \+
    chown -R radius ca_dir
  else
    echo "CA directory is not as expected. Falling back to c_rehash and restarting FreeRadius."
    c_rehash ca_dir
    chown -R radius ca_dir
    systemctl restart freeradius
  fi
  echo "done."
}

cmd_client_listcrl() {
  cd $CERTS_DIR
  openssl crl -in ca.crl -noout -text
}

help() {
  echo "$0 client add ...    : generate certificate for client"
  echo "$0 client test ...   : test certificate for client"
  echo "$0 client list       : list existing certificates"
  echo "$0 client revoke     : revoke client certificate"
  echo "$0 client listcrl    : show certificate revocation list"
  echo "$0 client updatecrl  : update certificate revocation list (e.g. after manual changes to index.txt)"
}

case "$1 $2" in
  "client add" | "client test" | "client list" | "client revoke" | "client listcrl" | "client updatecrl")
    cmd=cmd_$1_$2
    shift; shift
    $cmd "$@"
    ;;
  " " | "help ")
    help
    ;;
  *)
    echo "invalid command" >&2
    help
    exit 1
    ;;
esac
