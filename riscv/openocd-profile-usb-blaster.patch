--- a/src/jtag/drivers/usb_blaster/usb_blaster.c	2021-01-18 21:30:59.871128047 +0100
+++ b/src/jtag/drivers/usb_blaster/usb_blaster.c	2021-01-18 21:49:02.621601808 +0100
@@ -777,6 +777,19 @@
 	tap_set_state(TAP_RESET);
 }
 
+static void print_diff(struct timespec *start, struct timespec *end) {
+  struct timespec result;
+  if (end->tv_nsec >= start->tv_nsec) {
+    result.tv_sec = end->tv_sec - start->tv_sec;
+    result.tv_nsec = end->tv_nsec - start->tv_nsec;
+  } else {
+    result.tv_sec = end->tv_sec - start->tv_sec - 1;
+    result.tv_nsec = end->tv_nsec - start->tv_nsec + 1000*1000*1000;
+  }
+
+  printf("%d.%03d", result.tv_sec, result.tv_nsec/1000/1000);
+}
+
 static int ublast_execute_queue(void)
 {
 	struct jtag_command *cmd;
@@ -788,8 +801,12 @@
 		ublast_initial_wipeout();
 	}
 
+        struct timespec t1, t2, t3, t4;
+        int cnt = 0;
+        clock_gettime(CLOCK_MONOTONIC, &t1);
 	for (cmd = jtag_command_queue; ret == ERROR_OK && cmd != NULL;
 	     cmd = cmd->next) {
+                clock_gettime(CLOCK_MONOTONIC, &t2);
 		switch (cmd->type) {
 		case JTAG_RESET:
 			ublast_reset(cmd->cmd.reset->trst, cmd->cmd.reset->srst);
@@ -817,7 +834,16 @@
 			ret = ublast_scan(cmd->cmd.scan);
 			break;
 		}
+                clock_gettime(CLOCK_MONOTONIC, &t3);
+                printf("time for %d: ", cmd->type);
+                print_diff(&t2, &t3);
+                printf("\n");
+                cnt++;
 	}
+        clock_gettime(CLOCK_MONOTONIC, &t4);
+        printf("time for %d commands: ", cnt);
+        print_diff(&t1, &t4);
+        printf("\n");
 
 	ublast_flush_buffer();
 	return ret;
